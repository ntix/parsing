{"version":3,"file":"index.umd.js","sources":["../src/predicates/isBooleanType.ts","../src/predicates/isDateType.ts","../src/predicates/isNumberType.ts","../src/predicates/isStringType.ts","../src/predicates/isDate.ts","../src/predicates/isEqual.ts","../src/predicates/isFloat.ts","../src/predicates/isInt.ts","../src/predicates/isNullOrEmpty.ts","../src/parsing/createParseResult.ts","../src/parsing/parseChain.ts","../src/parsing/provideAnyOf.ts","../src/parsing/provideEquals.ts","../src/parsing/provideMax.ts","../src/parsing/provideMin.ts","../src/parsing/provideRange.ts","../src/parsing/numbers/getNumberEnumValues.ts","../src/parsing/numbers/ensureNumberArray.ts","../src/parsing/numbers/tryParseFloat.ts","../src/parsing/numbers/parseFloat.ts","../src/parsing/numbers/provideParseFloat.ts","../src/parsing/numbers/FloatParser.ts","../src/parsing/numbers/tryParseInt.ts","../src/parsing/numbers/provideParseInt.ts","../src/parsing/numbers/parseInt.ts","../src/parsing/numbers/IntParser.ts","../src/parsing/ParseErrors.ts","../src/parsing/parseAll.ts","../src/parsing/provideMaxLength.ts","../src/parsing/provideMinLength.ts","../src/parsing/provideRangeLength.ts","../src/parsing/arrays/provideParseArray.ts","../src/parsing/arrays/ArrayParser.ts","../src/parsing/booleans/tryParseBoolean.ts","../src/parsing/booleans/provideParseBoolean.ts","../src/parsing/booleans/BooleanParser.ts","../src/parsing/dates/tryParseDate.ts","../src/parsing/dates/parseDate.ts","../src/parsing/dates/ensureDateArray.ts","../src/parsing/dates/provideParseDate.ts","../src/parsing/dates/DateParser.ts","../src/parsing/complex/ComplexParser.ts","../src/parsing/strings/provideParseString.ts","../src/parsing/strings/StringParser.ts","../src/parsing/RootParser.ts","../src/Is.ts"],"sourcesContent":["export function isBooleanType(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n","/* check value is a Date type */\nexport function isDateType(value: unknown): value is Date {\n  return !!value && Object.prototype.toString.call(value) === '[object Date]';\n}\n","/** checks value is a number, includes NaN and Infinity */\nexport function isNumberType(value: unknown): value is number {\n  return typeof value === 'number';\n}\n","/** checks value is a string */\nexport function isStringType(value: unknown): value is string {\n  return typeof value === 'string';\n}\n","import { DateParsableTypes } from '../parsing';\nimport { isDateType } from './isDateType';\nimport { isNumberType } from './isNumberType';\nimport { isStringType } from './isStringType';\n\n/** checks value is a date */\nexport function isDate(value: unknown): value is DateParsableTypes {\n  if (isDateType(value)) return true;\n  if (isStringType(value)) return !isNaN(Date.parse(value));\n  if (isNumberType(value)) return !isNaN(value);\n\n  return false;\n}\n","/** deep equality check\n *\n * NOTE: arrays should be in the same order\n * */\nexport function isEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a))\n    return Array.isArray(b) && a.length === b.length && a.every((v, i) => isEqual(v, b[i]));\n\n  if (typeof a === 'object' || typeof b === 'object') {\n    const av = a.valueOf();\n    const bv = b.valueOf();\n    if (av !== a || bv !== b) return isEqual(av, bv);\n\n    return Object.keys({\n      ...a,\n      ...b\n    }).every(n => isEqual(a[n], b[n]));\n  }\n\n  return false;\n}\n","import { isNumberType } from './isNumberType';\nimport { isStringType } from './isStringType';\n\n/** checks values is a integer or a string which can be parsed into a integer */\nexport function isFloat(value: unknown): value is number | string {\n  if (isStringType(value)) value = Number.parseFloat(value);\n  return isNumberType(value) && !isNaN(value);\n}\n","import { isNumberType } from './isNumberType';\nimport { isStringType } from './isStringType';\n\n/** checks values is an integer or a string which can be parsed into a integer */\nexport function isInt(value: unknown): boolean {\n  if (isStringType(value)) value = Number.parseFloat(value);\n  return isNumberType(value) && !isNaN(value) && Number.isInteger(value);\n}\n","/** check for null (or undefined) or empty string */\n\nexport function isNullOrEmpty(value: unknown) {\n  return value == null || value === '';\n}\n","import { isEqual } from '../predicates';\nimport { ParseErrors } from './ParseErrors';\nimport { IParseResult } from './IParseResult';\nimport { IParseErrors } from './IParseErrors';\n\nexport function createParseResult<T>(\n  value: T, errors: IParseErrors = ParseErrors.empty\n): IParseResult<T> {\n\n  const success = isEqual(errors, ParseErrors.empty);\n\n  return {\n    value,\n    success,\n    errors: success ? ParseErrors.empty : errors // for quick check\n  };\n}\n","import { IParser } from './IParser';\nimport { createParseResult } from './createParseResult';\nimport { IParse } from './IParse';\n\nexport function parseChain<T>(\n  parent: IParser<unknown>, current: IParse<T>\n): IParse<T> {\n\n  return (value: unknown) => {\n    if (parent == null) {\n      // when root Schema\n      return current(value);\n    }\n\n    const parentResult = parent.parse(value);\n    const result = current(parentResult.value);\n\n    return createParseResult(result.value, {\n      ...parentResult.errors,\n      ...result.errors\n    });\n  };\n}\n","import { isEqual, isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { ParseErrors } from './ParseErrors';\n\n/**\n * Validate a value is any of values passed\n */\n\nexport function provideAnyOf<T>(\n  values: T[], negate: boolean\n) {\n\n  return (value: T) => {\n    if (isNullOrEmpty(value))\n      return createParseResult(null);\n\n    if (values.some(v => isEqual(v, value)) === !negate)\n      return createParseResult(value);\n\n    const errors = negate\n      ? ParseErrors.not(ParseErrors.anyOf(values))\n      : ParseErrors.anyOf(values);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isEqual, isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\n\nexport function provideEquals<T>(\n  equalToValue: T, negate: boolean\n) {\n\n  return (value: T) => {\n    if (isNullOrEmpty(value) || isEqual(value, equalToValue) !== negate)\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.equals(equalToValue);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\nimport { RelationalValidatorTypes } from './RelationalValidatorTypes';\n\n/**\n * Validate a value is a maximum\n */\nexport function provideMax<T extends RelationalValidatorTypes>(\n  maxValue: T, exclusive: boolean, negate: boolean\n) {\n\n  return (value: T) => {\n    if (isNullOrEmpty(value)\n      || (exclusive ? value < maxValue : value <= maxValue) !== negate)\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.max(maxValue, exclusive);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\nimport { RelationalValidatorTypes } from './RelationalValidatorTypes';\n\n/**\n * Validate a value is a minimum\n */\nexport function provideMin<T extends RelationalValidatorTypes>(\n  minValue: T, exclusive: boolean, negate: boolean\n) {\n\n  return (value: T) => {\n    if (isNullOrEmpty(value)\n      || (exclusive ? value > minValue : value >= minValue) !== negate)\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.min(minValue, exclusive);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\nimport { RelationalValidatorTypes } from './RelationalValidatorTypes';\n\n/**\n * Validate a value is a minimum\n */\nexport function provideRange<T extends RelationalValidatorTypes>(\n  minValue: T, maxValue: T, exclusive: boolean, negate: boolean\n) {\n\n  return (value: T) => {\n    if (isNullOrEmpty(value)\n      || (\n        (exclusive ? value > minValue : value >= minValue)\n        && (exclusive ? value < maxValue : value <= maxValue)\n      ) !== negate\n    )\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.range(minValue, maxValue, exclusive);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isInt } from '../../predicates';\nimport { NumberEnumMap } from './NumberEnumMap';\n\n/** get a number values array from the map */\nexport function getNumberEnumValues(value: NumberEnumMap) {\n  return Object.values(value).filter(v => isInt(v));\n}\n","import { getNumberEnumValues } from './getNumberEnumValues';\nimport { NumberParsableTypes } from './NumberParsableTypes';\nimport { NumberEnumMap } from './NumberEnumMap';\n\n/** get values array if not already */\nexport function ensureNumberArray(valuesOrEnum: NumberParsableTypes[] | NumberEnumMap) {\n  return Array.isArray(valuesOrEnum)\n    ? valuesOrEnum\n    : getNumberEnumValues(valuesOrEnum);\n}\n","import { isFloat, isNullOrEmpty, isNumberType } from '../../predicates';\nimport { NumberParsableTypes } from './NumberParsableTypes';\n\nexport function tryParseFloat(\n  value: NumberParsableTypes\n): number | null {\n  if (isNullOrEmpty(value) || !isFloat(value)) return null;\n  if (isNumberType(value)) return value;\n\n  return Number.parseFloat(value);\n}\n","import { NumberParsableTypes } from './NumberParsableTypes';\nimport { tryParseFloat } from './tryParseFloat';\n\nexport function parseFloat(value: NumberParsableTypes): number {\n  const result = tryParseFloat(value);\n\n  if (result === null)\n    throw new Error(`could not parse \"${value}\" as a number`);\n\n  return result;\n}\n","import { isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { ParseErrors } from '../ParseErrors';\nimport { NumberParsableTypes } from './NumberParsableTypes';\nimport { IParseResult } from '../IParseResult';\nimport { tryParseFloat } from './tryParseFloat';\n\nexport function provideParseFloat() {\n  return (value: unknown): IParseResult<number> => {\n    if (isNullOrEmpty(value))\n      return createParseResult(null);\n\n    const numberValue = tryParseFloat(value as NumberParsableTypes);\n    return numberValue === null\n      ? createParseResult(null, ParseErrors.float)\n      : createParseResult(numberValue);\n  };\n}\n","import { IParser } from '../IParser';\nimport { parseChain } from '../parseChain';\nimport { IFloat } from './IFloat';\nimport { NumberParsableTypes } from './NumberParsableTypes';\nimport { IParse } from '../IParse';\nimport { provideAnyOf } from '../provideAnyOf';\nimport { provideEquals } from '../provideEquals';\nimport { provideMax } from '../provideMax';\nimport { provideMin } from '../provideMin';\nimport { provideRange } from '../provideRange';\nimport { ensureNumberArray } from './ensureNumberArray';\nimport { parseFloat } from './parseFloat';\nimport { provideParseFloat } from './provideParseFloat';\n\n/**\n * Fluent builder for parsing floats\n */\nexport class FloatParser implements IFloat.Parser {\n  constructor(\n    private parent: IParser<unknown>,\n    private parseCurrent: IParse<number> = provideParseFloat(),\n    private negate: boolean = false\n  ) { }\n\n  readonly parse = parseChain(this.parent, this.parseCurrent);\n  readonly equals = (value: NumberParsableTypes) => new FloatParser(this, provideEquals(parseFloat(value), this.negate));\n  readonly anyOf = (values: NumberParsableTypes[]) => new FloatParser(this, provideAnyOf(ensureNumberArray(values), this.negate));\n  readonly min = (value: NumberParsableTypes, exclusive = false) => new FloatParser(this, provideMin(parseFloat(value), exclusive, this.negate));\n  readonly max = (value: NumberParsableTypes, exclusive = false) => new FloatParser(this, provideMax(parseFloat(value), exclusive, this.negate));\n  readonly range = (min: NumberParsableTypes, max: NumberParsableTypes, exclusive = false) => new FloatParser(this, provideRange(parseFloat(min), parseFloat(max), exclusive, this.negate));\n\n  get not() {\n    return new FloatParser(this.parent, this.parseCurrent, true);\n  }\n}\n","import { isInt, isNullOrEmpty, isNumberType } from '../../predicates';\nimport { NumberParsableTypes } from './NumberParsableTypes';\n\n/** Attempt to parse an integer value */\nexport function tryParseInt(\n  value: NumberParsableTypes, radix: number = undefined\n): number | null {\n  if (isNullOrEmpty(value) || !isInt(value)) return null;\n  if (isNumberType(value)) return value;\n\n  return Number.parseInt(value, radix);\n}\n","import { isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { IParseResult } from '../IParseResult';\nimport { ParseErrors } from '../ParseErrors';\nimport { NumberParsableTypes } from './NumberParsableTypes';\nimport { tryParseInt } from './tryParseInt';\n\nexport function provideParseInt() {\n  return (value: unknown): IParseResult<number> => {\n    if (isNullOrEmpty(value))\n      return createParseResult(null);\n\n    const numberValue = tryParseInt(value as NumberParsableTypes);\n    return numberValue === null\n      ? createParseResult(null, ParseErrors.int)\n      : createParseResult(numberValue);\n  };\n}\n","import { NumberParsableTypes } from './NumberParsableTypes';\nimport { tryParseInt } from './tryParseInt';\n\n/**\n * Parse the value passed\n *\n * @param value a parsable number type\n * @param radix base (2-36) defaults to 10 for decimal\n * @returns number or throws if not\n */\nexport function parseInt(value: NumberParsableTypes, radix: number): number {\n  const result = tryParseInt(value, radix);\n\n  if (result === null)\n    throw new Error(`could not parse \"${value}\" as a number`);\n\n  return result;\n}\n","import { IParser } from '../IParser';\nimport { parseChain } from '../parseChain';\nimport { NumberParsableTypes } from './NumberParsableTypes';\nimport { IParse } from '../IParse';\nimport { provideAnyOf } from '../provideAnyOf';\nimport { provideEquals } from '../provideEquals';\nimport { provideMax } from '../provideMax';\nimport { provideMin } from '../provideMin';\nimport { provideRange } from '../provideRange';\nimport { ensureNumberArray } from './ensureNumberArray';\nimport { IInt } from './IInt';\nimport { provideParseInt } from './provideParseInt';\nimport { parseInt } from './parseInt';\nimport { NumberEnumMap } from './NumberEnumMap';\n\n/**\n * Fluent builder for parsing ints\n */\nexport class IntParser implements IInt.Parser {\n  constructor(\n    private parent: IParser<unknown>,\n    private parseCurrent: IParse<number> = provideParseInt(),\n    private radix: number = undefined,\n    private negate: boolean = false\n  ) { }\n\n  readonly parse = parseChain(this.parent, this.parseCurrent);\n  readonly withRadix = (value?: number) => new IntParser(this.parent, this.parseCurrent, value, this.negate);\n  readonly equals = (value: NumberParsableTypes) => new IntParser(this, provideEquals(parseInt(value, this.radix), this.negate));\n  readonly anyOf = (values: NumberParsableTypes[] | NumberEnumMap) => new IntParser(this, provideAnyOf(ensureNumberArray(values), this.negate));\n  readonly min = (value: NumberParsableTypes, exclusive = false) => new IntParser(this, provideMin(parseInt(value, this.radix), exclusive, this.negate));\n  readonly max = (value: NumberParsableTypes, exclusive = false) => new IntParser(this, provideMax(parseInt(value, this.radix), exclusive, this.negate));\n  readonly range = (min: NumberParsableTypes, max: NumberParsableTypes, exclusive = false) => new IntParser(this, provideRange(parseInt(min, this.radix), parseInt(max, this.radix), exclusive, this.negate));\n\n  get not() {\n    return new IntParser(this.parent, this.parseCurrent, this.radix, true);\n  }\n}\n","import { NumberEnumMap, getNumberEnumValues } from './numbers';\n\n/**\n * Creates error objects\n */\nexport class ParseErrors {\n  /** not an error */\n  static readonly empty = {};\n  /** required */\n  static readonly required = { required: true };\n  /** wrap error in a not */\n  static readonly not = <T>(value: T) => ({ not: value });\n  /** value should be a boolean */\n  static readonly boolean = { boolean: true };\n  /** value should be an int */\n  static readonly int = { int: true };\n  /** value should be a float */\n  static readonly float = { float: true };\n  /** value should be a date */\n  static readonly date = { date: true };\n  /** value should be equal to the value */\n  static readonly equals = <T>(value: T) => ({ equals: value });\n  /** value should be equal to any of the values */\n  static readonly anyOf = <T>(values: T[] | NumberEnumMap) => ({ anyOf: Array.isArray(values) ? values : getNumberEnumValues(values) });\n  /** value should be at least */\n  static readonly min = <T>(value: T, exclusive: boolean) => ({ min: { value, exclusive } });\n  /** value should be at most */\n  static readonly max = <T>(value: T, exclusive: boolean) => ({ max: { value, exclusive } });\n  /** value should in range */\n  static readonly range = <T>(min: T, max: T, exclusive: boolean) => ({ range: { min, max, exclusive } });\n  /** value length should be at least */\n  static readonly minLength = <T>(value: T) => ({ minLength: value });\n  /** value length should be at most */\n  static readonly maxLength = <T>(value: T) => ({ maxLength: value });\n  /** value should in range */\n  static readonly rangeLength = <T>(min: T, max: T, exclusive: boolean) => ({ rangeLength: { min, max, exclusive } });\n  /** value should be an array */\n  static readonly array = { array: true };\n}\n","import { createParseResult } from './createParseResult';\nimport { IParse } from './IParse';\nimport { IParseResult } from './IParseResult';\n\n/**\n * parse all elements of an array\n *\n * @param parse function\n * @returns IParseResult<T[]>\n */\nexport function parseAll<T>(\n  parse: IParse<T>\n) {\n\n  return (values: unknown[]) => {\n    if (values == null) return createParseResult(null);\n\n    return values.reduce<IParseResult<T[]>>(\n      (r, value, index) => {\n\n        const result = parse(value);\n        const errors = result.success\n          ? r.errors\n          : { ...r.errors, [index]: result.errors };\n\n        return createParseResult(\n          [...r.value, result.value],\n          errors\n        );\n\n      }, createParseResult([])\n    );\n  };\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\nimport { IHasLength } from './IHasLength';\nimport { IParseResult } from './IParseResult';\n\nexport function provideMaxLength<T extends IHasLength>(\n  maxLength: number, exclusive: boolean, negate: boolean\n) {\n\n  return (value: T): IParseResult<T> => {\n    if (isNullOrEmpty(value)\n      || (exclusive ? value.length < maxLength : value.length <= maxLength) !== negate)\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.maxLength(maxLength);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\nimport { IHasLength } from './IHasLength';\nimport { IParseResult } from './IParseResult';\n\nexport function provideMinLength<T extends IHasLength>(\n  minLength: number, exclusive: boolean, negate: boolean\n) {\n\n  return (value: T): IParseResult<T> => {\n    if (isNullOrEmpty(value)\n      || (exclusive ? value.length > minLength : value.length >= minLength) !== negate)\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.minLength(minLength);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { createParseResult } from './createParseResult';\nimport { IParseErrors } from './IParseErrors';\nimport { ParseErrors } from './ParseErrors';\nimport { IHasLength } from './IHasLength';\nimport { IParseResult } from './IParseResult';\n\nexport function provideRangeLength<T extends IHasLength>(\n  minLength: number, maxLength: number, exclusive: boolean, negate: boolean\n) {\n\n  return (value: T): IParseResult<T> => {\n    if (isNullOrEmpty(value)\n      || (\n        (exclusive ? value.length > minLength : value.length >= minLength)\n        && (exclusive ? value.length < maxLength : value.length <= maxLength)\n      ) !== negate)\n      return createParseResult(value);\n\n    let errors: IParseErrors = ParseErrors.rangeLength(minLength, maxLength, exclusive);\n    if (negate)\n      errors = ParseErrors.not(errors);\n\n    return createParseResult(value, errors);\n  };\n}\n","import { isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { IParseResult } from '../IParseResult';\nimport { ParseErrors } from '../ParseErrors';\n\nexport function provideParseArray<T>() {\n\n  return (value: T): IParseResult<T[]> => {\n    if (isNullOrEmpty(value))\n      return createParseResult(null);\n\n    if (Array.isArray(value))\n      return createParseResult(value as T[]);\n\n    return createParseResult(null, ParseErrors.array);\n  };\n}\n","import { IParse } from '../IParse';\nimport { IParser } from '../IParser';\nimport { parseAll } from '../parseAll';\nimport { parseChain } from '../parseChain';\nimport { provideMaxLength } from '../provideMaxLength';\nimport { provideMinLength } from '../provideMinLength';\nimport { provideRangeLength } from '../provideRangeLength';\nimport { IArray } from './IArray';\nimport { provideParseArray } from './provideParseArray';\n\nexport class ArrayParser<T> implements IArray.Parser<T> {\n  constructor(\n    private parent: IParser<unknown>,\n    private parseCurrent: IParse<T[]> = provideParseArray<T>(),\n    private negate: boolean = false\n  ) { }\n\n  readonly parse = parseChain<T[]>(this.parent, this.parseCurrent);\n\n  readonly minLength = <T>(minValue: number, exclusive = false) => new ArrayParser<T>(this, provideMinLength<T[]>(minValue, exclusive, this.negate));\n  readonly maxLength = <T>(maxValue: number, exclusive = false) => new ArrayParser<T>(this, provideMaxLength<T[]>(maxValue, exclusive, this.negate));\n  readonly rangeLength = <T>(minValue: number, maxValue: number, exclusive = false) => new ArrayParser<T>(this, provideRangeLength<T[]>(minValue, maxValue, exclusive, this.negate));\n\n  readonly each = <T>(parser: IParser<T>) => ({ parse: parseChain<T[]>(this, parseAll(parser.parse)) });\n\n  get not() {\n    return new ArrayParser<T>(this.parent, this.parseCurrent, true);\n  }\n}\n","import { isBooleanType, isNullOrEmpty, isStringType } from '../../predicates';\n\n/** values considered to be a boolean true */\nexport const BOOLEANS_TRUE = [1, '1', 'true', 'on'];\n/** values considered to be a boolean false */\nexport const BOOLEANS_FALSE = [0, '0', 'false', 'off'];\n\n/**\n * try and parse the value as a boolean\n *\n * @param value value to parse\n * @returns boolean or a null if failed parse\n */\nexport function tryParseBoolean(value: unknown): boolean | null {\n  if (isNullOrEmpty(value)) return null;\n  if (isBooleanType(value)) return value;\n\n  if (isStringType(value))\n    value = value.toLowerCase();\n\n  if (BOOLEANS_TRUE.includes(value as string | number))\n    return true;\n  if (BOOLEANS_FALSE.includes(value as string | number))\n    return false;\n\n  return null;\n}\n","import { isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { IParseResult } from '../IParseResult';\nimport { ParseErrors } from '../ParseErrors';\nimport { tryParseBoolean } from './tryParseBoolean';\n\nexport function provideParseBoolean() {\n  return (value: unknown): IParseResult<boolean> => {\n    if (isNullOrEmpty(value)) return createParseResult(null);\n\n    value = tryParseBoolean(value);\n    return (value === null)\n      ? createParseResult(null, ParseErrors.boolean)\n      : createParseResult(value as boolean);\n  };\n}\n","import { provideEquals } from '../provideEquals';\nimport { IParse } from '../IParse';\nimport { IParser } from '../IParser';\nimport { parseChain } from '../parseChain';\nimport { provideParseBoolean } from './provideParseBoolean';\nimport { IBoolean } from './IBoolean';\n\n/**\n * Fluent builder for parsing booleans\n */\nexport class BooleanParser implements IBoolean.Parser {\n  constructor(\n    private parent: IParser<unknown>,\n    private parseCurrent: IParse<boolean> = provideParseBoolean(),\n    private negate: boolean = false\n  ) { }\n\n  readonly parse = parseChain(this.parent, this.parseCurrent);\n\n  readonly equals = (equalToValue: boolean) => new BooleanParser(this, provideEquals(equalToValue, this.negate));\n\n  get not() {\n    return new BooleanParser(this.parent, provideParseBoolean(), true);\n  }\n}\n","import { isDate, isDateType, isNullOrEmpty } from '../../predicates';\nimport { DateParsableTypes } from './DateParsableTypes';\n\n/**\n * Attempt to parse a value to a date\n *\n * TODO: improve, add support for user inputted strings US/UK etc\n * @param value to be parsed\n * @returns a date or null\n */\nexport function tryParseDate(value: DateParsableTypes): Date | null {\n  if (isNullOrEmpty(value)) return null;\n  if (isDateType(value)) return value;\n  if (!isDate(value)) return null;\n\n  return new Date(value);\n}\n","import { DateParsableTypes } from './DateParsableTypes';\nimport { tryParseDate } from './tryParseDate';\n\n/**\n * Parse a date, throw if not a date\n *\n * @param value to be parsed\n * @returns a date or null\n */\nexport function parseDate(value: DateParsableTypes): Date {\n  const result = tryParseDate(value);\n\n  if (result === null)\n    throw new Error(`could not parse \"${value}\" as a date`);\n\n  return result;\n}\n","import { DateParsableTypes } from './DateParsableTypes';\nimport { parseDate } from './parseDate';\n\nexport function ensureDateArray(values: DateParsableTypes[]): Date[] {\n  return values.map(parseDate);\n}\n","import { isDateType, isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { IParseResult } from '../IParseResult';\nimport { ParseErrors } from '../ParseErrors';\nimport { DateParsableTypes } from './DateParsableTypes';\nimport { tryParseDate } from './tryParseDate';\n\nexport function provideParseDate() {\n  return (value: unknown): IParseResult<Date> => {\n    if (isNullOrEmpty(value)) return createParseResult(null);\n    if (isDateType(value)) return createParseResult(value);\n\n    const dateValue = tryParseDate(value as DateParsableTypes);\n    return dateValue === null\n      ? createParseResult(null, ParseErrors.date)\n      : createParseResult(dateValue);\n  };\n}\n","import { IParser } from '../IParser';\nimport { provideMax } from '../provideMax';\nimport { parseChain } from '../parseChain';\nimport { IParse } from '../IParse';\nimport { provideEquals } from '../provideEquals';\nimport { provideMin } from '../provideMin';\nimport { provideAnyOf } from '../provideAnyOf';\nimport { provideRange } from '../provideRange';\nimport { ensureDateArray } from './ensureDateArray';\nimport { IDate } from './IDate';\nimport { parseDate } from './parseDate';\nimport { DateParsableTypes } from './DateParsableTypes';\nimport { provideParseDate } from './provideParseDate';\n\n/**\n * Fluent builder for parsing dates\n */\nexport class DateParser implements IDate.Parser {\n  static DefaultFormat = new Intl.DateTimeFormat();\n\n  constructor(\n    private parent: IParser<unknown>,\n    private parseCurrent: IParse<Date> = provideParseDate(),\n    private negate: boolean = false\n  ) { }\n\n  readonly parse = parseChain(this.parent, this.parseCurrent);\n  readonly equals = (value: DateParsableTypes) => new DateParser(this, provideEquals(parseDate(value), this.negate));\n  readonly anyOf = (values: DateParsableTypes[]) => new DateParser(this, provideAnyOf(ensureDateArray(values), this.negate));\n  readonly min = (value: DateParsableTypes, exclusive = false) => new DateParser(this, provideMin(parseDate(value), exclusive, this.negate));\n  readonly max = (value: DateParsableTypes, exclusive = false) => new DateParser(this, provideMax(parseDate(value), exclusive, this.negate));\n  readonly range = (min: DateParsableTypes, max: DateParsableTypes, exclusive = false) => new DateParser(this, provideRange(parseDate(min), parseDate(max), exclusive, this.negate));\n\n  get not() {\n    return new DateParser(this.parent, this.parseCurrent, true);\n  }\n}\n","import { isEqual, isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { IParser } from '../IParser';\nimport { IParseResult } from '../IParseResult';\nimport { parseChain } from '../parseChain';\nimport { ParseErrors } from '../ParseErrors';\nimport { IComplex } from './IComplex';\nimport { ComplexSchema } from './ComplexSchema';\n\nexport class ComplexParser<T> implements IComplex.Parser<T> {\n  constructor(private parent: IParser<unknown>, private schema: ComplexSchema<T>) { }\n\n  readonly parse = parseChain(this.parent, (originalValue: unknown) => {\n    if (isNullOrEmpty(originalValue))\n      return createParseResult(null);\n\n    return Object\n      .keys(this.schema)\n      .reduce<IParseResult<T>>((r, key) => {\n        const result = this.schema[key].parse(originalValue[key]);\n        const value\n          = result.value == null\n            ? r.value\n            : {\n              ...r.value,\n              [key]: result.value\n            };\n        const errors = isEqual(result.errors, ParseErrors.empty)\n          ? r.errors\n          : {\n            ...r.errors,\n            [key]: result.errors\n          };\n\n        return createParseResult(value, errors);\n      }, createParseResult(originalValue as T));\n  });\n}\n","import { isNullOrEmpty } from '../../predicates';\nimport { createParseResult } from '../createParseResult';\nimport { IParseResult } from '../IParseResult';\n\nexport function provideParseString() {\n  return (value: unknown): IParseResult<string> => {\n    if (isNullOrEmpty(value))\n      return createParseResult(null);\n\n    return createParseResult(value.toString());\n  };\n}\n","import { IParse } from '../IParse';\nimport { IParser } from '../IParser';\nimport { parseChain } from '../parseChain';\nimport { provideAnyOf } from '../provideAnyOf';\nimport { provideEquals } from '../provideEquals';\nimport { provideMaxLength } from '../provideMaxLength';\nimport { provideMinLength } from '../provideMinLength';\nimport { provideRangeLength } from '../provideRangeLength';\nimport { IString } from './IString';\nimport { provideParseString } from './provideParseString';\n\n/**\n * Fluent builder for parsing strings\n */\nexport class StringParser implements IString.Parser {\n  constructor(\n    private parent: IParser<unknown>,\n    private parseCurrent: IParse<string> = provideParseString(),\n    private negate: boolean = false\n  ) { }\n\n  readonly parse = parseChain(this.parent, this.parseCurrent);\n  readonly equals = (value: string) => new StringParser(this, provideEquals(value, this.negate));\n  readonly anyOf = (values: string[]) => new StringParser(this, provideAnyOf(values, this.negate));\n  readonly minLength = (value: number, exclusive = false) => new StringParser(this, provideMinLength<string>(value, exclusive, this.negate));\n  readonly maxLength = (value: number, exclusive = false) => new StringParser(this, provideMaxLength<string>(value, exclusive, this.negate));\n  readonly rangeLength = (min: number, max: number, exclusive = false) => new StringParser(this, provideRangeLength<string>(min, max, exclusive, this.negate));\n\n  get not() {\n    return new StringParser(this.parent, this.parseCurrent, true);\n  }\n}\n","import { isNullOrEmpty } from '../predicates';\nimport { ArrayParser, IArray } from './arrays';\nimport { BooleanParser, IBoolean } from './booleans';\nimport { createParseResult } from './createParseResult';\nimport { DateParser, IDate } from './dates';\nimport { IParser } from './IParser';\nimport { IRoot } from './IRootParser';\nimport { FloatParser, IFloat, IInt, IntParser } from './numbers';\nimport { ComplexParser, ComplexSchema, IComplex } from './complex';\nimport { parseChain } from './parseChain';\nimport { ParseErrors } from './ParseErrors';\nimport { IString, StringParser } from './strings';\n\nexport class RootParser implements IRoot.Parser {\n  constructor(\n    private isRequried = false\n  ) { }\n\n  readonly parse = parseChain(null, value =>\n    this.isRequried && isNullOrEmpty(value)\n      ? createParseResult(value, ParseErrors.required)\n      : createParseResult(value));\n\n  readonly boolean: IBoolean.Parser = new BooleanParser(this);\n  readonly int: IInt.Parser = new IntParser(this);\n  readonly float: IFloat.Parser = new FloatParser(this);\n  readonly date: IDate.Parser = new DateParser(this);\n  readonly string: IString.Parser = new StringParser(this);\n  readonly array: IArray.Parser<unknown> = new ArrayParser<unknown>(this);\n\n  readonly for = <T>(schema: ComplexSchema<T>): IComplex.Parser<T> => new ComplexParser(this, schema);\n  readonly use = <T>(parser: IParser<T>) => ({ parse: parseChain<T>(this, parser.parse) });\n}\n","import { IRoot, RootParser } from './parsing';\n\n/** Starting point for a new parsing and validating */\nexport class Is {\n  private constructor() {\n    throw new Error('static class');\n  }\n\n  static readonly required: IRoot.Parser = new RootParser(true);\n\n  static readonly boolean = new RootParser().boolean;\n  static readonly int = new RootParser().int;\n  static readonly float = new RootParser().float;\n  static readonly date = new RootParser().date;\n  static readonly string = new RootParser().string;\n  static readonly array = new RootParser().array;\n\n  static readonly for = new RootParser().for;\n  static readonly use = new RootParser().use;\n}\n"],"names":[],"mappings":"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"}